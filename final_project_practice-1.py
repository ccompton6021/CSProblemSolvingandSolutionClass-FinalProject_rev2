# -*- coding: utf-8 -*-
"""final_project_practice.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FBuCB6xFoQB2hOcB-9vtRBXSJcYsNXBm

Needed imports:
scipy.io -> reading audio file,
numpy -> for math computations(like cmath),
matplotib.pyplot -> for graphing results
"""

# Commented out IPython magic to ensure Python compatibility.
from scipy.io import wavfile
import scipy.io
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

'''
Reading the file using wavfile.read
Returns tuple with first element being the sample rate (in Hz),
second being the actual audio data (what makes the waves),
and third being the type (which we ignore)

Then we create a spectrogram which returns a tuple and we assign those
values appropriately

'''
sample_rate, data = wavfile.read('16bit1chan.wav')
spectrum, freqs, t, im = plt.specgram(data, Fs=sample_rate, \
      NFFT=1024, cmap=plt.get_cmap('autumn_r'))

# simple debugg function
# uncomment pass to disable calls
def debugg(string):
  # print(string)
   pass

# Want to establish the range of frequencies that
# we are going to work with by finding the max
# mid-range frequency (the target frequency)
def find_target_frequency(freqs):
  for x in freqs:
    if x > 1000:
      break
    return x

def frequency_check():

  # Using debugg function to check intermediate calculations
  debugg(f'freqs {freqs[:5]}')
  # Assign the mid range frequency as our target_frequency
  target_frequency = find_target_frequency(freqs)
  # Check debugg again
  debugg(f'target_frequency {target_frequency}')

  # Then we find the position (index) of where target_frequency is located
  # Used np.where as a condition to find the index in freqs array
  index_of_frequency = np.where(freqs == target_frequency)[0][0]
  debugg(f'index_of_frequency {index_of_frequency}')

  # After finding the index we look for the audio data associated with it
  # It seems that spectrum, freqs, t, etc, are all connected to each other
  # when plt.specgram was done
  data_for_frequency = spectrum[index_of_frequency]
  debugg(f'data_for_frequency {data_for_frequency}')

  # After finding the mid frequency, its index position in spectrum, and data
  # we convert its data from digital signal to decibles (db)
  data_in_db_fun = 10 * np.log10(data_for_frequency)
  return data_in_db_fun

"""Finding the -5dB"""
# Assigning the decible data into data_in_db
data_in_db = frequency_check()
plt.figure()

# Plotting the data where x is the time and y is the amplitude (power) in db
# linewidth sets the thickness of the line
# alpha sets the clarity (boldness) of the line. Ranges from 0-1
# plt.plot(t, data_in_db, linewidth=1, alpha=0.7, color='#004bc6')
# plt.xlabel('Time (s)')
# plt.ylabel('Power (dB)')

# Finding the index and value of the maximum decible
# and plotting it on the graph as a point.
# The last argument specifies that a red (keyword 'r')
# circle (keyword 'o') will be plotted according to the
# left arguments
index_of_max = np.argmax(data_in_db)
value_of_max = data_in_db[index_of_max]
# plt.plot(t[index_of_max], data_in_db[index_of_max], 'ro')

# Assigning the decible data into data_in_db
data_in_db = frequency_check()
plt.figure()

# slicing the data_in_db array so that it starts on the maximum db
sliced_array = data_in_db[index_of_max:]

# Now we find the maximum value 5 dB down which sets us up to find
# Rt20 which then helps us find Rt60
value_of_max_less_5 = value_of_max - 5
debugg(sliced_array[:10])
debugg(f'Max - 5 dB = {value_of_max_less_5}')

# We are now working with the sliced array which starts on the most
# maximum db value. Now we take that array and subtract the desired db
# ammount to get the true index and db value from sliced array(not data_in_db)
# Remmember that data_in_db contains all db values including the ones
# before the maximum.

# np.asarray just converts whatever you pass it into an array
# np.argmin returns the index of the minimum value.
def find_nearest_value(array, value):
  array = np.asarray(array)
  debugg(f'array {array[:10]}')
  idx = (np.abs(array - value)).argmin()
  debugg(f'idx {idx}')
  debugg(f'array[idx] {array[idx]}')
  return array[idx]

# See how we find the true max_less_5 db value using the function
# and then find its index in data_in_db
value_of_max_less_5 = find_nearest_value(sliced_array, value_of_max_less_5)

index_of_max_less_5 = np.where(data_in_db == value_of_max_less_5)
# After all of this we plot it
# Had to remake the graph since by only plotting the index_of_max_less_5,
# only a point showed up.
# The first four lines under this were taken from box/section 6
# plt.plot(t, data_in_db, linewidth=1, alpha=0.7, color='#004bc6')
# plt.xlabel('Time (s)')
# plt.ylabel('Power (dB)')
# plt.plot(t[index_of_max], data_in_db[index_of_max], 'ro')
# plt.plot(t[index_of_max_less_5], data_in_db[index_of_max_less_5], 'yo')

# We repeat what was done with the -5dB for the -25dB
value_of_max_less_25 = value_of_max - 25

value_of_max_less_25 = find_nearest_value(sliced_array, value_of_max_less_25)
index_of_max_less_25 = np.where(data_in_db == value_of_max_less_25)

# Then we plot everything. We could just leave all the plotting to the end
# instead of repeating the plots
plt.plot(t, data_in_db, linewidth=1, alpha=0.7, color='#004bc6')
plt.xlabel('Time (s)')
plt.ylabel('Power (dB)')
plt.plot(t[index_of_max], data_in_db[index_of_max], 'ro')
plt.plot(t[index_of_max_less_5], data_in_db[index_of_max_less_5], 'yo')
plt.plot(t[index_of_max_less_25], data_in_db[index_of_max_less_25], 'go')

# rt20 is the reverberation time (time it takes for sound to die down)
# between the -5dB and -25dB
rt20 = (t[index_of_max_less_5] - t[index_of_max_less_25])[0]

# Finally we calculate Rt60 and set some grids
rt60 = 3 * rt20

plt.grid()
plt.show()

print(f'The RT60 reverb time is {round(abs(rt60), 2)} seconds')


